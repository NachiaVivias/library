## Offline Dynamic Connectivity

### 概要

> 問題A (offline dynamic connectivity problem)
> 
> $n$頂点の無向グラフ$G$は空グラフで初期化されている。次の$3$種類のクエリがたくさん与えられるので、処理せよ。
>
> - **辺追加** : 組$(u,v)$が与えられる。頂点$u$と頂点$v$をつなぐ辺を$G$に追加せよ。
> - **辺削除** : 組$(u,v)$が与えられる。頂点$u$と頂点$v$をつなぐ辺を$G$から削除せよ。
> - **連結性** : 組$(u,v)$が与えられる。その時点で頂点$u$と頂点$v$が連結か判定せよ。
>
> 制約
> 
> - 多重辺、自己ループを与えてもよい。ただし、辺の削除には、辺追加クエリと同じ回数の辺削除クエリが必要である。
> - 辺削除のクエリで、その時点で存在しない辺を指定してはいけない。


> 問題B
>
> 問題Aに以下の制約を追加する。
> 
> - **辺追加**のクエリについて、頂点$u$と頂点$v$は連結でないことが保証される。（つまり$G$は常に森である。）また、多重辺や自己ループは与えられない。

このライブラリは、問題Aの**辺追加**と**辺削除**の情報をあらかじめすべて与えることで、次の$2$つの機能を提供する。

- 任意の**連結性**のクエリの答えが変わらないように、問題Aから問題Bへ変換する。
- 連結性のクエリを与えたときに高速に答える。

<!-- TODO ↓ 本当？実装のしやすさの可能性 -->
使いやすさのため、クエリ全体を$q$個のサイクルに分ける。各サイクルは

1. 辺追加クエリのみ処理
2. 辺削除クエリのみ処理
3. 連結性クエリのみ処理

の$3$ステップである。

### 使い方

サイクルの番号、頂点番号はどちらも$0$-indexedである。

**辺追加**のクエリと**辺削除**のクエリを合わせた総数を$Q$とする。

#### メンバ関数

- `OffLineDynamicConnectivity(n,q)`:

  $n,q$を設定する。計算量$\mathrm{O}(n+q)$

- `add_edge(t,u,v)`: 問題Aのサイクル$t$に、辺追加クエリ$(u,v)$を追加する。計算量均し$\mathrm{O}(1)$
- `del_edge(t,u,v)`: 問題Aのサイクル$t$に、辺削除クエリ$(u,v)$を追加する。計算量均し$\mathrm{O}(1)$
- `build()`: 問題Aの辺追加クエリと辺削除クエリの情報を与え終わった後に$1$回だけ呼び出されなければならない。計算量$\mathrm{O}(Q \log Q+q)$
- `run(add,del,query)`: 問題Bのクエリを関数呼び出しによって順次出力する。`build`よりも前に呼び出してはいけない。計算量$\mathrm{O}(Q (\log Q)^2+q)$

  - `void add(int u, int v)`

    問題Bの辺追加のクエリに対応して呼び出される。呼び出される回数は$\mathrm{O}(Q \log Q)$。

  - `void del(int u, int v)`

    問題Bの辺削除のクエリに対応して呼び出される。呼び出される回数は$\mathrm{O}(Q \log Q)$。

  - `void query(int t)`

    問題Bの連結性に対応して、サイクルごとに呼び出される。$t$はサイクルの番号である。$t=0,1,2,\ldots ,q-1$それぞれについて呼び出される。

#### メンバ変数

- `RollbackUnionFind uf`: メンバ関数`run`の実行中のみ、かつ **read-only** でのみ利用でき、その時点の$G$の連結性を表す。したがって連結性のクエリを計算量$\mathrm{O}(\log n)$で処理できる。
