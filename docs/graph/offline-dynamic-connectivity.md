## Offline Dynamic Connectivity

### 概要

> 問題A
> 
> $n$頂点の無向グラフ$G$は空グラフで初期化されている。$1$ステップは次の3段階からなる。これを$q$ステップ処理せよ。
>
> - **辺追加** : 「組$(u,v)$が与えられる。頂点$u$と頂点$v$をつなぐ辺を$G$に追加せよ。」というクエリを処理。
> - **辺削除** : 「組$(u,v)$が与えられる。頂点$u$と頂点$v$をつなぐ辺を$G$から削除せよ。」というクエリを処理。
> - **連結性** : 「組$(u,v)$が与えられる。頂点$u$と頂点$v$が連結か判定せよ。」というクエリを処理。
>
> 制約
> 
> - 多重辺、自己ループを与えてもよい。多重辺の削除には、**辺追加**クエリと同じ回数の**辺削除**クエリが必要である。
> - **辺削除**のクエリで、その時点で存在しない辺を削除してはいけない。


> 問題B
>
> 問題Aに以下の制約を追加する。
> 
> - **辺追加**のクエリについて、頂点$u$と頂点$v$は連結でないことが保証される。（つまり$G$は常に森である。）また、多重辺や自己ループは与えられない。

このライブラリは、問題Aの**辺追加**と**辺削除**の情報をあらかじめすべて与えることで、次の$2$つの機能を提供する。

- 任意の**連結性**のクエリの答えが変わらないように、問題Aから問題Bへ変換する。
- 各ステップで連結性のクエリを与えたときに高速に答える。



### 使い方

ステップの番号、頂点番号はどちらも$0$-indexedである。

**辺追加**のクエリと**辺削除**のクエリを合わせた総数を$Q$とする。

#### メンバ関数

- `OffLineDynamicConnectivity(n,q)`:

  $n,q$を設定する。計算量$\mathrm{O}(n+q)$

- `add_edge(t,u,v)`: ステップ$t$の**辺追加**に、組$(u,v)$のクエリを追加する。計算量均し$\mathrm{O}(1)$
- `del_edge(t,u,v)`: ステップ$t$の**辺削除**に、組$(u,v)$のクエリを追加する。計算量均し$\mathrm{O}(1)$
- `build()`: **辺追加**と**辺削除**の情報を与え終わった後に$1$回だけ呼び出されなければならない。計算量$\mathrm{O}(Q \log Q+q)$
- `run(add,del,query)`: 問題Bを出力する。計算量計算量$\mathrm{O}(Q (\log Q)^2+q)$

  - `add(int u, int v)`

    問題Bの**辺追加**のクエリに対応して呼び出される。

  - `del(int u, int v)`

    問題Bの**辺削除**のクエリに対応して呼び出される。

  - `query(int t)`

    問題Bの**連結性**に対応して、ステップごとに呼び出される。$t$はステップの番号である。

#### メンバ変数

- `uf`: メンバ関数`run`の実行中、かつ改変しない用途でのみ利用できる。型は`RollbackUnionFind`であり、その時点の$G$の連結性を表す。したがって**連結性**のクエリを計算量$\mathrm{O}(\log n)$で処理できる。
